  (def digits ["zero" "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"])
  (def sorted-digits (->> digits
                          (filter #(= (get % 1) \i))
                          reverse))
  (println "A backwards list of the digits with a second character of 'i':")
  (doall (map println sorted-digits))
  (def products products-list)
  (def order-groups (map #(hash-map :category (% 0), :products (% 1))
                          (group-by #(:category %) products)))
  (doall (map println order-groups))
  (def numbers-a [0 2 4 5 6 8 9])
  (def numbers-b [1 3 5 7 8])
  (def all-numbers (flatten [numbers-a numbers-b]))
  (println "All numbers from both arrays:")
  (println all-numbers)
  (doall (map println all-numbers))
  (println "All numbers from both arrays:")
  (doall (map println all-numbers))
ls
(let [a 10])
a
(defn test [] (let [a 10]) (println a))
(defn linq73 []
  (let [factors-of-300 [2 2 3 5 5]
        unique-factors (count (distinct factors-of-300))]    
    (println "There are" unique-factors "unique factors of 300.")))
(linq73)
(defn linq74 []
  (let [numbers [4 5 1 3 9 0 6 7 2 0]
        odd-numbers (count (filter #(= 1 (mod % 2)) numbers))]
    (println "There are" odd-numbers "odd numbers in the list.")))
(linq74)
  (def customers customers-list)
  (def order-counts (map #(hash-map :customer-id (:customer-id %)
                                    :order-count (count (:orders %)))
                         customers))
  (doall (map println order-counts))
(order-counts)
order-counts
    (def order-counts (for [c customers] 
                        {:customer-id (:customer-id %)
                         :order-count (count (:orders %))})
                         customers))
    (def order-counts (for [c customers] 
                        {:customer-id (:customer-id c)
                         :order-count (count (:orders c))}))
order-counts
(defn linq76 []
  (let [customers customers-list
        order-counts 
        (for [c customers]
          {:customer-id (:customer-id c) :order-count (count (:orders c))})]
  (doall (map println order-counts))))
(linq76)
(def customers customers-list)
(->> customers (for [c] {:a c}))
(->> customers #(for {:a %}))
(defn linq77 []
  (let [products products-list
        category-counts
        (->> products
             (group-by :category)
             (map #(hash-map :category (get % 0),
                             :product-count (count (get % 1)))))]
    (doall (map println category-counts))))
(linq77)
(defn linq77 []
  (let [products products-list
        category-counts
        (->> products
             (group-by :category)
             (map #(identity {:category (get % 0),
                              :product-count (count (get % 1))})))]
    (doall (map println category-counts))))
(linq77)
(defn linq77 []
  (let [products products-list
        category-counts
        (->> products
             (group-by :category)
             (map #(identity {:category (first %),
                              :product-count (count (second %))})))]
    (doall (map println category-counts))))
(linq77)
(defn linq79 []
  (let [words ["cherry", "apple", "blueberry"]
        total-chars (reduce + (map count words))]
    (println "There are a total of" total-chars "characters in these words.")))
(linq79)
(linq80)
(defn linq80 []
  (let [products products-list
        categories
        (->> products
             (group-by :category)
             (map #(identity 
                    {:category (get % 0),
                     :total-units-in-stock (reduce + (map :units-in-stock (get % 1)))})))]
    (doall (map println categories))))
(linq80)
(defn linq82 []
  (let [words ["cherry", "apple", "blueberry"]
        shortest-word (apply min (map count words))]
    (println "The shortest word is" shortest-word "characters long.")))
(linq82)
(defn linq83 []
  (let [products products-list
        categories
        (->> products
             (group-by :category)
             (map #(identity {:category (get % 0),
                             :cheapest-price (apply min (map :unit-price (get % 1)))})))]
    (doall (map println categories))))
(linq83)
(defn linq84 []
  (let [products products-list
        categories
        (->> products
         (group-by :category)
             (map (fn [g]
                    (let [min-price (apply min (map :unit-price (get g 1)))]
                      (hash-map
                       :category (get g 0)
                       :cheapest-products
                       (filter #(= (:unit-price %) min-price)
                               (get g 1))
                       )
                      )))
             )]
    (doall (map println categories))))
(linq84)
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doall (map println q))))
(defn join [coll with-coll matcher]
  (map (fn [x] {:key x :items (filter (fn [y] (matcher x y)) with-coll)})
       coll))
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doall (map println q))))
(linq102)
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doseq [product q]
      (println " " (:product-name product))))
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doseq [product q]
      (println " " (:product-name product)))))
(linq102
)
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doseq [v q]
      (println (:product-name v) ":" (:category v)))))
(linq102)
(defn linq103[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (map #(identity {:category (:key %), :products (:items %)})
               (join categories products #(= %1 (:category %2))))]
    (doseq [pc q]
    (println (:category pc))
    (doseq [product (:products pc)]
      (println " " (:product-name product))))))
(linq103)
(defn linq103[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (for [pc (join categories products #(= %1 (:category %2)))] 
            {:category (:key %), :products (:items %)})]
    (doseq [pc q]
      (println (:category pc))
      (doseq [product (:products pc)]
        (println " " (:product-name product))))))
(defn linq103[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (for [pc (join categories products #(= %1 (:category %2)))] 
            {:category (:key pc), :products (:items pc)})]
    (doseq [pc q]
      (println (:category pc))
      (doseq [product (:products pc)]
        (println " " (:product-name product))))))
(linq103)
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                              (:items pc)))
                (join categories products #(= %1 (:category %2)))))]
    (doseq [v q]
      (println (:product-name v) ":" (:category v)))))
(defn linq102 []
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                              (:items pc)))
                (join categories products #(= %1 (:category %2)))))]
    (doseq [v q]
      (println (:product-name v) ":" (:category v)))))
(linq102)
(defn linq103[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (for [pc (join categories products #(= %1 (:category %2)))] 
            {:category (:key pc), :products (:items pc)})]
    (doseq [pc q]
      (println (:category pc))
      (doseq [product (:products pc)]
        (println " " (:product-name product))))))
(linq103)
(defn linq104[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc] (map #(identity {:category (:key pc), :product-name (:product-name %)})
                          (:items pc)))
            (join categories products #(= %1 (:category %2)))))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(linq104)
(defn linq104[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc]               
              (for [p (:items pc)] {:category (:key pc), :product-name (:product-name p)})
              ))
            (join categories products #(= %1 (:category %2)))))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(defn linq104[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (map
            (fn [pc]               
              (for [p (:items pc)] {:category (:key pc), :product-name (:product-name p)})
              )
            (join categories products #(= %1 (:category %2)))))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(linq104)
(defn linq104[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q (flatten 
           (for [pc (join categories products #(= %1 (:category %2)))]
            (for [p (:items pc)] {:category (:key pc), :product-name (:product-name p)})
            ))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(linq104)
(defn linq105[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q
        (flatten
         (map (fn [pc]
            (if (empty? (:items pc))
              {:category (:key pc), :product-name "(No products)"}
              (map #(identity {:category (:key pc), :product-name (:product-name %)})
                   (:items pc))))
          (join categories products #(= %1 (:category %2)))))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(linq105)
(defn linq105[]
  (let [categories ["Beverages", "Condiments", "Vegetables", "Dairy Products", "Seafood"]
        products products-list
        q
        (flatten
         (for [pc (join categories products #(= %1 (:category %2)))]
            (if (empty? (:items pc))
              {:category (:key pc), :product-name "(No products)"}
              (for [p (:items pc)] 
                {:category (:key pc), :product-name (:product-name p)}))))]
    (doseq [p q]
    (println (:product-name p) ":" (:category p)))))
(linq105)
